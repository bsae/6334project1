/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pkg6334project1;

import java.io.*;
import java.util.*;
import javafx.util.Pair;

/**
 *
 * @author Humberto Saenz
 */
public class OS extends Thread {

    public static ArrayList<PCB> New_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Ready_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Wait_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Terminated_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Currently_Running = new ArrayList<PCB>();//beto's code, remind him :)

    public static ArrayList<Double> Arrival_Times = new ArrayList<>();
    public static ArrayList<Double> Waiting_Times = new ArrayList<>();
    public static ArrayList<Double> End_Times = new ArrayList<>();
    public static CPU cpu = new CPU(10);//set to 10 to enforce FCFS/PS
    public IOdevice io = new IOdevice(Wait_Queue);
    
    public boolean isCPUAvailable;
    // need to make processTable

    public static ArrayList<PCB> initialPCBs = new ArrayList<PCB>();
    
    
    public OS(){
        cpu.start();
        io.start();
    }

    //Read the txt input file, for each line, create a process and record its arrival
//time
    void FCFS() {
        int globalTime = 0;//overall time, when arrivaltime == global, put in readyQ
        int initialTime = 0;
        
        //to make functions cleaner, new queue is being generated by outside function
        New_Queue = Gen_New_Queue();
        int totalProcesses = New_Queue.size();
        
        //if ready queue is emp,
        //I N I T I A L I Z E
        if(Ready_Queue.isEmpty())
        {
            for(int i = 0; i < New_Queue.size(); ++i)
            {
                //loop through entire queue, until first thing is ready to arrive
                //shove into queue
                if (New_Queue.get(0).arrivalOrder == globalTime)
                {
                    Ready_Queue.add(New_Queue.get(0));
                    New_Queue.remove(New_Queue.get(0));
                    break;
                }
                
             //do one instance of work, increment time
            New_Queue.get(i).BubbleSort();
            globalTime++;                
            }
        }
        
        //keep looping until term queue is full
        while(Terminated_Queue.size() != totalProcesses)
        {   
            //first things first, if first thing in newQ is ready
            //shove into readyQ
            while(New_Queue.get(0).arrivalOrder == globalTime)
            {
                //add to readyQ, remove from NewQ
                Ready_Queue.add(New_Queue.get(0));
                New_Queue.remove(0);
            }
            
            //if index even -> CPU thread -> running queue
            //if index odd -> IO thread ->IO queue
            
            //if butstSeq index is even then push to running queue and take out of ready queue
            if(Ready_Queue.get(0).programCounter % 2 == 0)
            {
                Currently_Running.add(Ready_Queue.get(0));
                Ready_Queue.remove(0);
                Pair<Integer, String> executed;
                executed = cpu.execute(Currently_Running.get(0));
                //execute one run of bubblesort, increment global time
                globalTime++;
                
                //loop through burstSeq iterations and add to readyQueue if time applies
                for (int i = 0; i < Currently_Running.get(0).burstSeq.get(Currently_Running.get(0).programCounter); ++i)
                {  
                   //if first thing in newQ is ready to go, add to ready queue
                   while(New_Queue.get(0).arrivalOrder == globalTime)
                   {
                        //add to readyQ, remove from NewQ
                        Ready_Queue.add(New_Queue.get(0));
                        New_Queue.remove(0); 
                   }
                   
                   //run bubble sort for as many processes as needed, increment time
                   executed = cpu.execute(Currently_Running.get(0));
                   globalTime++;                   
                }
                
                
                //if returned status after execution is wait -> waitQ,remove from CR
                if(executed.getValue() == "wait")
                {
                    //if burstSequence at end, then put in terminated queue
                    //checking current program counter and if same size as burst seq list
                    if(Currently_Running.get(0).programCounter == Currently_Running.get(0).burstSeq.size())
                    {
                        //shove currently running thing into terminated queue, remove from currently runningQ
                        Terminated_Queue.add(Currently_Running.get(0));
                        Currently_Running.remove(0);
                    }
                    else
                    {
                        //TODO: add timers / threads
                        Wait_Queue.add(Currently_Running.get(0));
                        Currently_Running.remove(0);
                    }

                }
                //otherwise, it will return "ready", terminate if over, else, shove into ReadyQ, remove from CR
                else
                {
                    if(Currently_Running.get(0).programCounter == Currently_Running.get(0).burstSeq.size())
                    {
                        //shove currently running thing into terminated queue, remove from currently runningQ
                        Terminated_Queue.add(Currently_Running.get(0));
                        Currently_Running.remove(0);
                    }
                    else
                    {
                        //TODO: add timers / threads
                        Ready_Queue.add(Currently_Running.get(0));
                        Currently_Running.remove(0);
                    }
                }
            }
            //add in IO device stuff
            else
            {
                //add to wait queue, remove from running, execute 
                Wait_Queue.add(Currently_Running.get(0));
                Currently_Running.remove(0);
                io.execute(Wait_Queue.get(0));//returns ready, add to Q
                Wait_Queue.get(0).programCounter++;
                Ready_Queue.add(Wait_Queue.get(0));
                Wait_Queue.remove(0);
                
            }
            
            //***start of beto code
//            // if the waitQ is not empty, execute the amount of times in the io burst sequence at this programCounter
//            if(Wait_Queue.isEmpty() == false){
//                io.execute(Wait_Queue.get(0).burstSeq.get(Wait_Queue.get(0).programCounter);
//                //increment globalTime however many times the io executes
//                for(int i = 0; i < Wait_Queue.get(0).programCounter; i++){
//                globalTime++;
//                }
//                //Move the programCounter
//                Wait_Queue.get(0).programCounter++;
//
//                //put back process back into ReadyQ, and remove process from waitQ
//                Ready_Queue.add(Wait_Queue.get(0));
//                Wait_Queue.remove(0);
//            }
            //***end of beto code
            
            globalTime++;
        }
        
        
        
        
        }
    public ArrayList<PCB> Gen_New_Queue()
    {
        ArrayList<PCB> result = new ArrayList<PCB>();
        File input = new File("C:\\Users\\frank\\Desktop\\6334project1\\src\\input.txt");
        //in format of ID, ARRIVAL, PRIORITY, BURST SEQ
        try(Scanner sc = new Scanner(input))
        {
            //store current process in temp var, store in Queue
            PCB tempPCB = new PCB();
            String seq;//temp string to split stuff up
            String seqString;
            while(sc.hasNext())
            {
                seqString = "";
                //make new PCB, store stuff from file into PCB and store in list
                
                tempPCB = new PCB();
                tempPCB.ID = Integer.parseInt(sc.next());
                tempPCB.arrivalOrder = Integer.parseInt(sc.next());
                tempPCB.priority = Integer.parseInt(sc.next());
//            	tempPCB.ID = sc.nextInt();
//            	tempPCB.arrivalOrder = sc.nextInt();
//            	tempPCB.priority = sc.nextInt();
                
                //store next big int into some int seq, convert to string,
                //loop through string, storing digits into int array
                seq = sc.next();
                seqString = String.valueOf(seq);
                for (int j = 0; j < seqString.length(); ++j)
                {
                    tempPCB.burstSeq.add((Character.getNumericValue(seqString.charAt(j))));
                    //tempPCB.burstSeq.add(Integer.getInteger(seqString.indexOf(j)));
                }
                
                //after building PCB, store into result, return as New_Queue
                result.add(tempPCB);
            }
            
        }
        catch (FileNotFoundException e)
        {
            
        }
        return result;
    }
    
    void RR()
    {
        //TODO
    }
    
    void PS()
    {
        //TODO
    }
    
    public void run()
    {
        try{
            for (int i = 0; i < 10; i++){
                
                System.out.println("OS Thread Running: " + i);
                Thread.sleep(50);
                i += 1;
            }
        } catch (InterruptedException e) {
        //handle 
        }
    }
}//end of OS class

    


    //Put each process in New_Q queue initially then put them in Ready_Q
    //Always check whether the CPU is idle or not; if yes, use your scheduler
    //algorithm to select a process from the Ready_Queue for CPU execution\
    // According to the return value of CPU execute(), put the process into the
//corresponding queue.
    //Record the time of every operation for computing your latency and
//response

