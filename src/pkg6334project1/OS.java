/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pkg6334project1;

import java.io.*;
import java.util.*;

/**
 *
 * @author Humberto Saenz
 */
public class OS extends Thread {

    public static ArrayList<PCB> New_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Ready_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Wait_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Terminated_Queue = new ArrayList<PCB>();
    public static ArrayList<PCB> Currently_Running = new ArrayList<PCB>();//beto's code, remind him :)

    public static ArrayList<Double> Arrival_Times = new ArrayList<>();
    public static ArrayList<Double> Waiting_Times = new ArrayList<>();
    public static ArrayList<Double> End_Times = new ArrayList<>();
    //public static CPU cpu = new CPU();
    //public IODevice io = new IODevice(Wait_Queue);
    public boolean isCPUAvailable;
    // need to make processTable

    public static ArrayList<PCB> initialPCBs = new ArrayList<PCB>();

    //Read the txt input file, for each line, create a process and record its arrival
//time
    void FCFS() {
        int globalTime = 0;//overall time, when arrivaltime == global, put in readyQ
        int initialTime = 0;
        
        //to make functions cleaner, new queue is being generated by outside function
        New_Queue = Gen_New_Queue();
        int totalProcesses = New_Queue.size();
        
        //if ready queue is emp, INITIALIZE
        if(Ready_Queue.isEmpty())
        {
            for(int i = 0; i < New_Queue.size(); ++i)
            {
                //loop through entire queue, until first thing is ready to arrive
                //shove into queue
                if (New_Queue.get(0).arrivalOrder == initialTime)
                {
                    Ready_Queue.add(New_Queue.get(0));
                    New_Queue.remove(New_Queue.get(0));
                    break;
                }
                
             //do one instance of work, increment time
            New_Queue.get(i).BubbleSort();
            initialTime++;                
            }
        }
        
        //keep looping until term queue is full
        while(Terminated_Queue.size() != totalProcesses)
        {   
            //first things first, if first thing in newQ is ready
            //shove into readyQ
            if(New_Queue.get(0).arrivalOrder == globalTime)
            {
                //add to readyQ, remove from NewQ
                Ready_Queue.add(New_Queue.get(0));
                New_Queue.remove(0);
            }
            
            //if index even -> CPU thread -> running queue
            //if index odd -> IO thread ->IO queue
            
            //if
            if(Ready_Queue.get(0).burstSeq.get(Ready_Queue.get(0).programCounter) % 2 == 0)
            {
                
            }
        }
        
        
        
        
        }
    public ArrayList<PCB> Gen_New_Queue()
    {
        ArrayList<PCB> result = new ArrayList<PCB>();
        File input = new File("C:\\Users\\Chen\\Documents\\Git\\6334project1\\src\\pkg6334project1\\input.txt");
        try(Scanner sc = new Scanner(input))
        {
            //store current process in temp var, store in Queue
            PCB tempPCB = new PCB();
            String seq;//temp string to split stuff up
            String seqString;
            while(sc.hasNext())
            {
                seqString = "";
                //make new PCB, store stuff from file into PCB and store in list
                
                tempPCB = new PCB();
                tempPCB.ID = Integer.parseInt(sc.next());
                tempPCB.arrivalOrder = Integer.parseInt(sc.next());
                tempPCB.priority = Integer.parseInt(sc.next());
//            	tempPCB.ID = sc.nextInt();
//            	tempPCB.arrivalOrder = sc.nextInt();
//            	tempPCB.priority = sc.nextInt();
                
                //store next big int into some int seq, convert to string,
                //loop through string, storing digits into int array
                seq = sc.next();
                seqString = String.valueOf(seq);
                for (int j = 0; j < seqString.length(); ++j)
                {
                    tempPCB.burstSeq.add((Character.getNumericValue(seqString.charAt(j))));
                    //tempPCB.burstSeq.add(Integer.getInteger(seqString.indexOf(j)));
                }
                
                //after building PCB, store into result, return as New_Queue
                result.add(tempPCB);
            }
            
        }
        catch (FileNotFoundException e)
        {
            
        }
        return result;
    }
    
    
    }//end of OS class

    


    //Put each process in New_Q queue initially then put them in Ready_Q
    //Always check whether the CPU is idle or not; if yes, use your scheduler
    //algorithm to select a process from the Ready_Queue for CPU execution\
    // According to the return value of CPU execute(), put the process into the
//corresponding queue.
    //Record the time of every operation for computing your latency and
//response

